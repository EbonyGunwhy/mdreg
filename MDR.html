<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>MDR.MDR API documentation</title>
<meta name="description" content="MODEL DRIVEN REGISTRATION (MDR) for quantitative renal MRI
MDR Library
@Kanishka Sharma
@Joao Almeida e Sousa
@Steven Sourbron
2021" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MDR.MDR</code></h1>
</header>
<section id="section-intro">
<p>MODEL DRIVEN REGISTRATION (MDR) for quantitative renal MRI
MDR Library
@Kanishka Sharma
@Joao Almeida e Sousa
@Steven Sourbron
2021</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
MODEL DRIVEN REGISTRATION (MDR) for quantitative renal MRI
MDR Library
@Kanishka Sharma
@Joao Almeida e Sousa
@Steven Sourbron
2021
&#34;&#34;&#34;

import os
import numpy as np
import SimpleITK as sitk
import itk
import pandas as pd

def model_driven_registration(images, image_parameters, signal_model_parameters, elastix_model_parameters, precision = 1): 
    &#34;&#34;&#34; main function that performs the model driven registration.

    Args:
    ----
        images (numpy.ndarray): unregistered 2D images (uint16) with shape [x-dim, y-dim, number of slices]
        image_parameters (sitk tuple): distance between pixels (in mm) along each dimension
        signal_model_parameters (list): a list consisting of a constant &#39;MODEL&#39; which is the imported signal model and signal model specific parameters as the subsequent elements of the list.
        eg - [MODEL, T2_prep_times], where MODEL is the python script within the &#39;model&#39; module containing the T2 signal model and &#39;T2_prep_times&#39; are the T2 specific model input parameters. 
        elastix_model_parameters (itk-elastix.ParameterObject): elastix file registration parameters
        precision (int, optional): precision (in mm) to define the convergence criterion for MDR. Defaults to 1.

    Returns:
    -------
        coregistered (numpy.ndarray): ffd based co-registered (uint16) 2D images as np-array with shape: [x-dim,y-dim, number of slices]
        fit (numpy.ndarray: signal model fit image (uint16) as np-array and shape [x-dim,y-dim, num of slices]
        deformation_field (numpy.ndarray): output deformation fields - deformation_field_x and deformation_field_y as np-array with shape [x-dim, y-dim, 2, num of slices]
        par (list): signal model-fit parameters as a list
        improvement (dataframe): maximum deformation per pixel calculated as the euclidean distance of difference between old and new deformation field appended to a dataframe until convergence criterion is met.
    
    &#34;&#34;&#34;
    shape = np.shape(images)
    improvement = []  

    # Initialise the solution
    coregistered =  np.reshape(images,(shape[0]*shape[1],shape[2]))
    deformation_field = np.zeros((shape[0]*shape[1],2,shape[2]))

    converged = False
    while not converged: 

        # Update the solution
        fit, par = fit_signal_model_image(shape, coregistered, signal_model_parameters)
        coregistered, new_deformation_field = fit_coregistration(shape, fit, images, image_parameters, elastix_model_parameters)

        # check convergence    
        improvement.append(maximum_deformation_per_pixel(deformation_field, new_deformation_field))
        converged = improvement[-1] &lt;= precision           
        deformation_field = new_deformation_field

    coregistered = np.reshape(coregistered,(shape[0],shape[1],shape[2]))
    deformation_field = np.reshape(deformation_field,(shape[0],shape[1],2,shape[2])) 
    improvement = pd.DataFrame({&#39;maximum_deformation_per_pixel&#39;: improvement}) 

    return coregistered, fit, deformation_field, par, improvement


def fit_signal_model_image(shape, coregistered, signal_model_parameters):
    &#34;&#34;&#34;Fit signal model images.
    
    Args:
    ----
    shape (tuple): tuple with original image shape [x-dim,y-dim,z-dim]
    coregistered (numpy.ndarray): co-registerd 2D images as np-array with shape [x-dim * y-dim, number of slices]
    signal_model_parameters (list): a list consisting of a constant &#39;MODEL&#39; which is the imported signal model and signal model specific parameters as the subsequent elements of the list.
    eg - [MODEL, T2_prep_times], where MODEL is the python script within the &#39;model&#39; module containing the T2 signal model and &#39;T2_prep_times&#39; are the T2 specific model input parameters. 
    
    Returns:
    -------
    fit (numpy.ndarray): signal model fit images (2D slices) as np-array with shape: [x-dim,y-dim, num of slices]
    par (list): signal model-fit parameters as a list.
    &#34;&#34;&#34;

    fit = np.zeros((shape[0]*shape[1],shape[2]))
    par = np.array([]) 
    for x in range(shape[0]*shape[1]):#pixels
      fit[x,:], par_x = fit_signal_model_pixel(coregistered[x,:], signal_model_parameters) 
      par = np.append(par, par_x)
    fit = np.reshape(fit,(shape[0],shape[1],shape[2]))
    return fit, par


def fit_coregistration(shape, fit, images, image_parameters, elastix_model_parameters):
    &#34;&#34;&#34;Co-register the 2D fit-image with the unregistered 2D input image.

    Args:
    ----
    shape (tuple): tuple with original image shape [x-dim,y-dim,z-dim]
    fit (numpy.ndarray): signal model fit images (2D slices) with shape: [x-dim,y-dim, num of slices]
    images (numpy.ndarray): unregistered 2D images (uint16) as np-array with shape [x-dim,y-dim, number of slices]
    image_parameters (sitk tuple): image parameters define the pixel spacing in the image
    elastix_model_parameters (list): elastix parameter file parameters

    Returns:
    -------
    coregistered (numpy.ndarray: coregisterd 2D images with shape [x-dim * y-dim, number of slices]
    deformation_field (numpy.ndarray): output deformation fields with shape [x-dim, y-dim, 2, num of slices]. Dimension &#39;2&#39; corresponds to deformation_field_x and deformation_field_y. 
    &#34;&#34;&#34;

    coregistered = np.zeros((shape[0]*shape[1],shape[2]))
    deformation_field = np.zeros([shape[0]*shape[1], 2, shape[2]])
    for t in range(shape[2]): #dynamics
      coregistered[:,t], deformation_field[:,:,t] = itkElastix_MDR_coregistration(images[:,:,t], fit[:,:,t], elastix_model_parameters, image_parameters)
    return coregistered, deformation_field


def maximum_deformation_per_pixel(deformation_field, new_deformation_field):
    &#34;&#34;&#34;
    This function calculates diagnostics from the registration process
    It takes as input the original deformation field and the new deformation field
    and returns the maximum deformation per pixel.
    The maximum deformation per pixel calculated as 
    the euclidean distance of difference between old and new deformation field. 
    &#34;&#34;&#34;

    df_difference = deformation_field - new_deformation_field
    df_difference_x_squared = np.square(df_difference[:,0,:].squeeze())
    df_difference_y_squared = np.square(df_difference[:,1,:].squeeze())
    dist = np.sqrt(np.add(df_difference_x_squared, df_difference_y_squared))
    maximum_deformation_per_pixel = np.nanmax(dist)
    
    return maximum_deformation_per_pixel 

# signal model function for MDR
def fit_signal_model_pixel(time_curve, signal_model_parameters): 
    &#34;&#34;&#34;
        This function takes signal time curve and signal model parameters as input 
        and returns the fitted signal and associated model parameters.
    &#34;&#34;&#34;
    fit, fitted_parameters = getattr(signal_model_parameters[0], &#39;main&#39;)(time_curve, signal_model_parameters[1])
    return fit, fitted_parameters


# deformable registration for MDR
def itkElastix_MDR_coregistration(target, source, elastix_model_parameters, image_parameters):
    &#34;&#34;&#34;
        This function takes unregistered source image and target image as input 
        and returns ffd based co-registered image and corresponding deformation field. 
    &#34;&#34;&#34;
    shape_source = np.shape(source)
    shape_target = np.shape(target)

    source = sitk.GetImageFromArray(source)
    #source.SetOrigin(image_parameters[0]) # not required for MDR based time-series registration only
    source.SetSpacing(image_parameters)
    source.__SetPixelAsUInt16__
    source = np.reshape(source, [shape_source[0], shape_source[1]]) 
    
    target = sitk.GetImageFromArray(target)
    #target.SetOrigin(image_parameters[0]) # not required for MDR based time-series registration only
    target.SetSpacing(image_parameters)
    target.__SetPixelAsUInt16__
    target = np.reshape(target, [shape_target[0], shape_target[1]])
    
    ## read the source and target images
    elastixImageFilter = itk.ElastixRegistrationMethod.New()
    elastixImageFilter.SetFixedImage(itk.GetImageFromArray(np.array(source, np.float32)))
    elastixImageFilter.SetMovingImage(itk.GetImageFromArray(np.array(target, np.float32)))

    ## call the parameter map file specifying the registration parameters
    elastixImageFilter.SetParameterObject(elastix_model_parameters) 
    ## print Parameter Map
    print(elastix_model_parameters)

    ## set additional options
    elastixImageFilter.SetNumberOfThreads(os.cpu_count()-1)
    elastixImageFilter.SetLogToConsole(True)
    ## update filter object (required)
    elastixImageFilter.UpdateLargestPossibleRegion()

    ## RUN ELASTIX using ITK-Elastix filters
    coregistered = itk.GetArrayFromImage(elastixImageFilter.GetOutput()).flatten()

    transformixImageFilter = itk.TransformixFilter.New()
    transformixImageFilter.SetTransformParameterObject(elastixImageFilter.GetTransformParameterObject())
    transformixImageFilter.ComputeDeformationFieldOn()
    transformixImageFilter.SetMovingImage(itk.GetImageFromArray(np.array(target, np.float32)))
    deformation_field = itk.GetArrayFromImage(transformixImageFilter.GetOutputDeformationField()).flatten()
    deformation_field = np.reshape(deformation_field, [int(len(deformation_field)/2), 2])

    return coregistered, deformation_field</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MDR.MDR.fit_coregistration"><code class="name flex">
<span>def <span class="ident">fit_coregistration</span></span>(<span>shape, fit, images, image_parameters, elastix_model_parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Co-register the 2D fit-image with the unregistered 2D input image.</p>
<h2 id="args">Args:</h2>
<p>shape (tuple): tuple with original image shape [x-dim,y-dim,z-dim]
fit (numpy.ndarray): signal model fit images (2D slices) with shape: [x-dim,y-dim, num of slices]
images (numpy.ndarray): unregistered 2D images (uint16) as np-array with shape [x-dim,y-dim, number of slices]
image_parameters (sitk tuple): image parameters define the pixel spacing in the image
elastix_model_parameters (list): elastix parameter file parameters</p>
<h2 id="returns">Returns:</h2>
<p>coregistered (numpy.ndarray: coregisterd 2D images with shape [x-dim * y-dim, number of slices]
deformation_field (numpy.ndarray): output deformation fields with shape [x-dim, y-dim, 2, num of slices]. Dimension '2' corresponds to deformation_field_x and deformation_field_y.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_coregistration(shape, fit, images, image_parameters, elastix_model_parameters):
    &#34;&#34;&#34;Co-register the 2D fit-image with the unregistered 2D input image.

    Args:
    ----
    shape (tuple): tuple with original image shape [x-dim,y-dim,z-dim]
    fit (numpy.ndarray): signal model fit images (2D slices) with shape: [x-dim,y-dim, num of slices]
    images (numpy.ndarray): unregistered 2D images (uint16) as np-array with shape [x-dim,y-dim, number of slices]
    image_parameters (sitk tuple): image parameters define the pixel spacing in the image
    elastix_model_parameters (list): elastix parameter file parameters

    Returns:
    -------
    coregistered (numpy.ndarray: coregisterd 2D images with shape [x-dim * y-dim, number of slices]
    deformation_field (numpy.ndarray): output deformation fields with shape [x-dim, y-dim, 2, num of slices]. Dimension &#39;2&#39; corresponds to deformation_field_x and deformation_field_y. 
    &#34;&#34;&#34;

    coregistered = np.zeros((shape[0]*shape[1],shape[2]))
    deformation_field = np.zeros([shape[0]*shape[1], 2, shape[2]])
    for t in range(shape[2]): #dynamics
      coregistered[:,t], deformation_field[:,:,t] = itkElastix_MDR_coregistration(images[:,:,t], fit[:,:,t], elastix_model_parameters, image_parameters)
    return coregistered, deformation_field</code></pre>
</details>
</dd>
<dt id="MDR.MDR.fit_signal_model_image"><code class="name flex">
<span>def <span class="ident">fit_signal_model_image</span></span>(<span>shape, coregistered, signal_model_parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Fit signal model images.</p>
<h2 id="args">Args:</h2>
<p>shape (tuple): tuple with original image shape [x-dim,y-dim,z-dim]
coregistered (numpy.ndarray): co-registerd 2D images as np-array with shape [x-dim * y-dim, number of slices]
signal_model_parameters (list): a list consisting of a constant 'MODEL' which is the imported signal model and signal model specific parameters as the subsequent elements of the list.
eg - [MODEL, T2_prep_times], where MODEL is the python script within the 'model' module containing the T2 signal model and 'T2_prep_times' are the T2 specific model input parameters. </p>
<h2 id="returns">Returns:</h2>
<p>fit (numpy.ndarray): signal model fit images (2D slices) as np-array with shape: [x-dim,y-dim, num of slices]
par (list): signal model-fit parameters as a list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_signal_model_image(shape, coregistered, signal_model_parameters):
    &#34;&#34;&#34;Fit signal model images.
    
    Args:
    ----
    shape (tuple): tuple with original image shape [x-dim,y-dim,z-dim]
    coregistered (numpy.ndarray): co-registerd 2D images as np-array with shape [x-dim * y-dim, number of slices]
    signal_model_parameters (list): a list consisting of a constant &#39;MODEL&#39; which is the imported signal model and signal model specific parameters as the subsequent elements of the list.
    eg - [MODEL, T2_prep_times], where MODEL is the python script within the &#39;model&#39; module containing the T2 signal model and &#39;T2_prep_times&#39; are the T2 specific model input parameters. 
    
    Returns:
    -------
    fit (numpy.ndarray): signal model fit images (2D slices) as np-array with shape: [x-dim,y-dim, num of slices]
    par (list): signal model-fit parameters as a list.
    &#34;&#34;&#34;

    fit = np.zeros((shape[0]*shape[1],shape[2]))
    par = np.array([]) 
    for x in range(shape[0]*shape[1]):#pixels
      fit[x,:], par_x = fit_signal_model_pixel(coregistered[x,:], signal_model_parameters) 
      par = np.append(par, par_x)
    fit = np.reshape(fit,(shape[0],shape[1],shape[2]))
    return fit, par</code></pre>
</details>
</dd>
<dt id="MDR.MDR.fit_signal_model_pixel"><code class="name flex">
<span>def <span class="ident">fit_signal_model_pixel</span></span>(<span>time_curve, signal_model_parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes signal time curve and signal model parameters as input
and returns the fitted signal and associated model parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_signal_model_pixel(time_curve, signal_model_parameters): 
    &#34;&#34;&#34;
        This function takes signal time curve and signal model parameters as input 
        and returns the fitted signal and associated model parameters.
    &#34;&#34;&#34;
    fit, fitted_parameters = getattr(signal_model_parameters[0], &#39;main&#39;)(time_curve, signal_model_parameters[1])
    return fit, fitted_parameters</code></pre>
</details>
</dd>
<dt id="MDR.MDR.itkElastix_MDR_coregistration"><code class="name flex">
<span>def <span class="ident">itkElastix_MDR_coregistration</span></span>(<span>target, source, elastix_model_parameters, image_parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes unregistered source image and target image as input
and returns ffd based co-registered image and corresponding deformation field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def itkElastix_MDR_coregistration(target, source, elastix_model_parameters, image_parameters):
    &#34;&#34;&#34;
        This function takes unregistered source image and target image as input 
        and returns ffd based co-registered image and corresponding deformation field. 
    &#34;&#34;&#34;
    shape_source = np.shape(source)
    shape_target = np.shape(target)

    source = sitk.GetImageFromArray(source)
    #source.SetOrigin(image_parameters[0]) # not required for MDR based time-series registration only
    source.SetSpacing(image_parameters)
    source.__SetPixelAsUInt16__
    source = np.reshape(source, [shape_source[0], shape_source[1]]) 
    
    target = sitk.GetImageFromArray(target)
    #target.SetOrigin(image_parameters[0]) # not required for MDR based time-series registration only
    target.SetSpacing(image_parameters)
    target.__SetPixelAsUInt16__
    target = np.reshape(target, [shape_target[0], shape_target[1]])
    
    ## read the source and target images
    elastixImageFilter = itk.ElastixRegistrationMethod.New()
    elastixImageFilter.SetFixedImage(itk.GetImageFromArray(np.array(source, np.float32)))
    elastixImageFilter.SetMovingImage(itk.GetImageFromArray(np.array(target, np.float32)))

    ## call the parameter map file specifying the registration parameters
    elastixImageFilter.SetParameterObject(elastix_model_parameters) 
    ## print Parameter Map
    print(elastix_model_parameters)

    ## set additional options
    elastixImageFilter.SetNumberOfThreads(os.cpu_count()-1)
    elastixImageFilter.SetLogToConsole(True)
    ## update filter object (required)
    elastixImageFilter.UpdateLargestPossibleRegion()

    ## RUN ELASTIX using ITK-Elastix filters
    coregistered = itk.GetArrayFromImage(elastixImageFilter.GetOutput()).flatten()

    transformixImageFilter = itk.TransformixFilter.New()
    transformixImageFilter.SetTransformParameterObject(elastixImageFilter.GetTransformParameterObject())
    transformixImageFilter.ComputeDeformationFieldOn()
    transformixImageFilter.SetMovingImage(itk.GetImageFromArray(np.array(target, np.float32)))
    deformation_field = itk.GetArrayFromImage(transformixImageFilter.GetOutputDeformationField()).flatten()
    deformation_field = np.reshape(deformation_field, [int(len(deformation_field)/2), 2])

    return coregistered, deformation_field</code></pre>
</details>
</dd>
<dt id="MDR.MDR.maximum_deformation_per_pixel"><code class="name flex">
<span>def <span class="ident">maximum_deformation_per_pixel</span></span>(<span>deformation_field, new_deformation_field)</span>
</code></dt>
<dd>
<div class="desc"><p>This function calculates diagnostics from the registration process
It takes as input the original deformation field and the new deformation field
and returns the maximum deformation per pixel.
The maximum deformation per pixel calculated as
the euclidean distance of difference between old and new deformation field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maximum_deformation_per_pixel(deformation_field, new_deformation_field):
    &#34;&#34;&#34;
    This function calculates diagnostics from the registration process
    It takes as input the original deformation field and the new deformation field
    and returns the maximum deformation per pixel.
    The maximum deformation per pixel calculated as 
    the euclidean distance of difference between old and new deformation field. 
    &#34;&#34;&#34;

    df_difference = deformation_field - new_deformation_field
    df_difference_x_squared = np.square(df_difference[:,0,:].squeeze())
    df_difference_y_squared = np.square(df_difference[:,1,:].squeeze())
    dist = np.sqrt(np.add(df_difference_x_squared, df_difference_y_squared))
    maximum_deformation_per_pixel = np.nanmax(dist)
    
    return maximum_deformation_per_pixel </code></pre>
</details>
</dd>
<dt id="MDR.MDR.model_driven_registration"><code class="name flex">
<span>def <span class="ident">model_driven_registration</span></span>(<span>images, image_parameters, signal_model_parameters, elastix_model_parameters, precision=1)</span>
</code></dt>
<dd>
<div class="desc"><p>main function that performs the model driven registration.</p>
<h2 id="args">Args:</h2>
<pre><code>images (numpy.ndarray): unregistered 2D images (uint16) with shape [x-dim, y-dim, number of slices]
image_parameters (sitk tuple): distance between pixels (in mm) along each dimension
signal_model_parameters (list): a list consisting of a constant 'MODEL' which is the imported signal model and signal model specific parameters as the subsequent elements of the list.
eg - [MODEL, T2_prep_times], where MODEL is the python script within the 'model' module containing the T2 signal model and 'T2_prep_times' are the T2 specific model input parameters. 
elastix_model_parameters (itk-elastix.ParameterObject): elastix file registration parameters
precision (int, optional): precision (in mm) to define the convergence criterion for MDR. Defaults to 1.
</code></pre>
<h2 id="returns">Returns:</h2>
<pre><code>coregistered (numpy.ndarray): ffd based co-registered (uint16) 2D images as np-array with shape: [x-dim,y-dim, number of slices]
fit (numpy.ndarray: signal model fit image (uint16) as np-array and shape [x-dim,y-dim, num of slices]
deformation_field (numpy.ndarray): output deformation fields - deformation_field_x and deformation_field_y as np-array with shape [x-dim, y-dim, 2, num of slices]
par (list): signal model-fit parameters as a list
improvement (dataframe): maximum deformation per pixel calculated as the euclidean distance of difference between old and new deformation field appended to a dataframe until convergence criterion is met.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_driven_registration(images, image_parameters, signal_model_parameters, elastix_model_parameters, precision = 1): 
    &#34;&#34;&#34; main function that performs the model driven registration.

    Args:
    ----
        images (numpy.ndarray): unregistered 2D images (uint16) with shape [x-dim, y-dim, number of slices]
        image_parameters (sitk tuple): distance between pixels (in mm) along each dimension
        signal_model_parameters (list): a list consisting of a constant &#39;MODEL&#39; which is the imported signal model and signal model specific parameters as the subsequent elements of the list.
        eg - [MODEL, T2_prep_times], where MODEL is the python script within the &#39;model&#39; module containing the T2 signal model and &#39;T2_prep_times&#39; are the T2 specific model input parameters. 
        elastix_model_parameters (itk-elastix.ParameterObject): elastix file registration parameters
        precision (int, optional): precision (in mm) to define the convergence criterion for MDR. Defaults to 1.

    Returns:
    -------
        coregistered (numpy.ndarray): ffd based co-registered (uint16) 2D images as np-array with shape: [x-dim,y-dim, number of slices]
        fit (numpy.ndarray: signal model fit image (uint16) as np-array and shape [x-dim,y-dim, num of slices]
        deformation_field (numpy.ndarray): output deformation fields - deformation_field_x and deformation_field_y as np-array with shape [x-dim, y-dim, 2, num of slices]
        par (list): signal model-fit parameters as a list
        improvement (dataframe): maximum deformation per pixel calculated as the euclidean distance of difference between old and new deformation field appended to a dataframe until convergence criterion is met.
    
    &#34;&#34;&#34;
    shape = np.shape(images)
    improvement = []  

    # Initialise the solution
    coregistered =  np.reshape(images,(shape[0]*shape[1],shape[2]))
    deformation_field = np.zeros((shape[0]*shape[1],2,shape[2]))

    converged = False
    while not converged: 

        # Update the solution
        fit, par = fit_signal_model_image(shape, coregistered, signal_model_parameters)
        coregistered, new_deformation_field = fit_coregistration(shape, fit, images, image_parameters, elastix_model_parameters)

        # check convergence    
        improvement.append(maximum_deformation_per_pixel(deformation_field, new_deformation_field))
        converged = improvement[-1] &lt;= precision           
        deformation_field = new_deformation_field

    coregistered = np.reshape(coregistered,(shape[0],shape[1],shape[2]))
    deformation_field = np.reshape(deformation_field,(shape[0],shape[1],2,shape[2])) 
    improvement = pd.DataFrame({&#39;maximum_deformation_per_pixel&#39;: improvement}) 

    return coregistered, fit, deformation_field, par, improvement</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MDR" href="index.html">MDR</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MDR.MDR.fit_coregistration" href="#MDR.MDR.fit_coregistration">fit_coregistration</a></code></li>
<li><code><a title="MDR.MDR.fit_signal_model_image" href="#MDR.MDR.fit_signal_model_image">fit_signal_model_image</a></code></li>
<li><code><a title="MDR.MDR.fit_signal_model_pixel" href="#MDR.MDR.fit_signal_model_pixel">fit_signal_model_pixel</a></code></li>
<li><code><a title="MDR.MDR.itkElastix_MDR_coregistration" href="#MDR.MDR.itkElastix_MDR_coregistration">itkElastix_MDR_coregistration</a></code></li>
<li><code><a title="MDR.MDR.maximum_deformation_per_pixel" href="#MDR.MDR.maximum_deformation_per_pixel">maximum_deformation_per_pixel</a></code></li>
<li><code><a title="MDR.MDR.model_driven_registration" href="#MDR.MDR.model_driven_registration">model_driven_registration</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>