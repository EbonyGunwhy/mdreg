<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>MDR.MDR API documentation</title>
<meta name="description" content="MODEL DRIVEN REGISTRATION (MDR) for quantitative MRI
MDR Library for 2D image registration
@Kanishka Sharma
@Joao Almeida e Sousa
@Steven â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MDR.MDR</code></h1>
</header>
<section id="section-intro">
<p>MODEL DRIVEN REGISTRATION (MDR) for quantitative MRI<br>
MDR Library for 2D image registration<br>
@Kanishka Sharma<br>
@Joao Almeida e Sousa<br>
@Steven Sourbron<br>
2021</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
MODEL DRIVEN REGISTRATION (MDR) for quantitative MRI  
MDR Library for 2D image registration  
@Kanishka Sharma  
@Joao Almeida e Sousa  
@Steven Sourbron  
2021
&#34;&#34;&#34;

import os
import numpy as np
import SimpleITK as sitk
import itk
import copy
import pandas as pd
import multiprocessing
from tqdm import tqdm


def model_driven_registration(images, image_parameters, model, signal_model_parameters, elastix_model_parameters, precision = 1,  function = &#39;main&#39;, parallel = False, log = True): 
    &#34;&#34;&#34; main function that performs the model driven registration.

    Args:
    ----
        images (numpy.ndarray): unregistered 2D images (uint16) from the selected single MR slice with shape [x-dim, y-dim, total timeseries].     
        image_parameters (sitk tuple): distance between pixels (in mm) along each dimension.    
        model (module): import module for the signal model to fit.    
        signal_model_parameters (list()): list consisting of signal model input parameters.   
        eg: TE (echo times) as input parameter (independent variable) for T2*sequence model fit.    
        elastix_model_parameters (itk-elastix.ParameterObject): elastix file registration parameters.    
        precision (int, optional): precision (in mm) to define the convergence criterion for MDR. Defaults to 1. Lower value means higher precision.    
        function (string, optional): name (user-defined) of the main model-fit function. Default is &#39;main&#39;.
        parallel (bool, optional): This flag determines if the co-registration is ran on 1 (&#39;False&#39;, default) or multiple CPU cores (&#39;True&#39;).
        log (bool, optional): Default of this flag is &#39;True&#39; and it prints the ITK-Elastix output in the terminal.
    
    Returns:
    -------
        coregistered (numpy.ndarray): ffd based co-registered (uint16) 2D images as np-array with shape: [x-dim,y-dim,  total time-series] of the selected input MR slice  
        fit (numpy.ndarray): signal model fit images (uint16) of specified MR slice with shape [x-dim,y-dim,  total time-series]  
        deformation_field (numpy.ndarray): output 2D deformation fields, &#39;deformation_field_x&#39; and &#39;deformation_field_y&#39; as np-array with shape [x-dim, y-dim, 2,  total timeseries]  
        par (numpy.ndarray): signal model-fit output parameters  
        improvement (dataframe): maximum deformation per pixel calculated as the euclidean distance of difference between old and new deformation field appended to a dataframe until convergence criterion is met.
    &#34;&#34;&#34;
 
    shape = np.shape(images)
    improvement = []  

    # Initialise the solution
    coregistered = copy.deepcopy(images) 
    coregistered =  np.reshape(coregistered,(shape[0]*shape[1],shape[2]))
    deformation_field = np.empty((shape[0]*shape[1],2,shape[2]))

    converged = False
    while not converged: 

        # Update the solution
        fit, par = fit_signal_model_image(coregistered, model, signal_model_parameters, function=function)
        fit = np.reshape(fit,(shape[0],shape[1],shape[2]))
        # perform 2D image registration
        coregistered, new_deformation_field = fit_coregistration(fit, images, image_parameters, elastix_model_parameters, parallel=parallel, log=log)
        # check convergence    
        improvement.append(maximum_deformation_per_pixel(deformation_field, new_deformation_field))
        converged = improvement[-1] &lt;= precision           
        deformation_field = new_deformation_field

    coregistered = np.reshape(coregistered,(shape[0],shape[1],shape[2]))
    deformation_field = np.reshape(deformation_field,(shape[0],shape[1],2,shape[2])) 
    improvement = pd.DataFrame({&#39;maximum_deformation_per_pixel&#39;: improvement}) 

    return coregistered, fit, deformation_field, par, improvement

# signal model function for MDR
def fit_signal_model_image(time_curve, model, signal_model_parameters, function=&#39;main&#39;): 
    &#34;&#34;&#34;
        This function takes signal time curve, signal model parameters, and model fit function name as input 
        and returns the fitted signal and associated output model parameters.
    &#34;&#34;&#34;
    fit, fitted_parameters = getattr(model, function)(time_curve, signal_model_parameters)
    return fit, fitted_parameters


def fit_coregistration(fit, images, image_parameters, elastix_model_parameters, parallel = False, log = True):
    &#34;&#34;&#34;Co-register the 2D fit-image with the unregistered 2D input image.

    Args:
    ----
    fit (numpy.ndarray): signal model fit images (single 2D slice with all time-series) with shape: [x-dim,y-dim, total timeseries]  
    images (numpy.ndarray): unregistered 2D images (uint16, single 2D slice with all time-series) as np-array with shape [x-dim,y-dim, total timeseries]  
    image_parameters (sitk tuple): distance between pixels (in mm) along each dimension  
    elastix_model_parameters (itk-elastix.ParameterObject): elastix file registration parameters
    parallel (bool, optional): This flag determines if the co-registration is ran on 1 (&#39;False&#39;, default) or multiple CPU cores (&#39;True&#39;).
    log (bool, optional): Default of this flag is &#39;True&#39; and it prints the ITK-Elastix output in the terminal.

    Returns:
    -------
    coregistered (numpy.ndarray): coregisterd 2D images with shape [x-dim * y-dim, total time-series]  
    deformation_field (numpy.ndarray): output 2D deformation fields with shape [x-dim, y-dim, 2, num of dynamics].  
    Dimension &#39;2&#39; corresponds to deformation_field_x and deformation_field_y.  
    &#34;&#34;&#34;
    shape = np.shape(images)
    coregistered = np.empty((shape[0]*shape[1],shape[2]))
    deformation_field = np.empty([shape[0]*shape[1], 2, shape[2]])
    if parallel == False:
        for t in tqdm(range(shape[2]), desc=&#39;Co-registration progress&#39;): #dynamics
            coregistered[:,t], deformation_field[:,:,t] = itkElastix_MDR_coregistration(images[:,:,t], fit[:,:,t], elastix_model_parameters, image_parameters, parallel=False, log=log)
    else:
        pool = multiprocessing.Pool(processes=os.cpu_count()-1)
        dict_param = get_dictionary_parameters_from_elastix_parameters(elastix_model_parameters)
        arguments = [(t, images, fit, dict_param, image_parameters, log) for t in range(shape[2])] #dynamics
        results = list(tqdm(pool.imap(parallel_MDR_coregistration, arguments), total=shape[2], desc=&#39;Co-registration progress&#39;))
        for i, result in enumerate(results):
            coregistered[:, i] = result[0]
            deformation_field[:, :, i] = result[1]
    return coregistered, deformation_field


def parallel_MDR_coregistration(parallel_arguments):
    &#34;&#34;&#34;
        This function calls itkElastix_MDR_coregistration when parallel=True. 
        It runs and distributes the mentioned function to multiple cores.
    &#34;&#34;&#34;
    t, images, fit, elastix_model_parameters, image_parameters, log = parallel_arguments
    coregistered_t, deformation_field_t = itkElastix_MDR_coregistration(images[:,:,t], fit[:,:,t], elastix_model_parameters, image_parameters, parallel=True, log=log)
    return coregistered_t, deformation_field_t


def get_dictionary_parameters_from_elastix_parameters(elastix_model_parameters):
    &#34;&#34;&#34;
        This function converts the non-pickable object elastix_model_parameters and converts it into a list of dictionaries.
        This is only called when parallel=True and the purpose is to make the multiprocessing possible and successful.
    &#34;&#34;&#34;
    list_dictionaries_parameters = []
    for index in range(elastix_model_parameters.GetNumberOfParameterMaps()):
        parameter_map = elastix_model_parameters.GetParameterMap(index)
        one_parameter_map_dict = {}
        for i in parameter_map:
            one_parameter_map_dict[i] = parameter_map[i]
        list_dictionaries_parameters.append(one_parameter_map_dict)
    return list_dictionaries_parameters


def get_elastix_parameters_from_dictionary_parameters(list_dictionaries_parameters):
    &#34;&#34;&#34;
        This function converts the list of dictionaries to the non-pickable object elastix_model_parameters during the itkElastix_MDR_coregistration processing.
        This is only called when parallel=True and the purpose is to make the multiprocessing possible and successful.
    &#34;&#34;&#34;
    elastix_model_parameters = itk.ParameterObject.New()
    for one_map in list_dictionaries_parameters:
        elastix_model_parameters.AddParameterMap(one_map)
    return elastix_model_parameters


def maximum_deformation_per_pixel(deformation_field, new_deformation_field):
    &#34;&#34;&#34;This function calculates diagnostics from the registration process.

    It takes as input the original deformation field and the new deformation field
    and returns the maximum deformation per pixel (in mm).
    The maximum deformation per pixel is calculated as 
    the euclidean distance of difference between the old and new deformation field. 
    &#34;&#34;&#34;

    df_difference = deformation_field - new_deformation_field
    df_difference_x_squared = np.square(df_difference[:,0,:].squeeze())
    df_difference_y_squared = np.square(df_difference[:,1,:].squeeze())
    dist = np.sqrt(np.add(df_difference_x_squared, df_difference_y_squared))
    maximum_deformation_per_pixel = np.nanmax(dist)
    
    return maximum_deformation_per_pixel


# deformable registration for MDR
def itkElastix_MDR_coregistration(target, source, elastix_model_parameters, image_parameters, parallel = False, log = True):
    &#34;&#34;&#34;
        This function takes pair-wise unregistered source image and target image (per time-series point) as input 
        and returns ffd based co-registered target image and its corresponding deformation field. 
    &#34;&#34;&#34;
    shape_source = np.shape(source)
    shape_target = np.shape(target)

    source = sitk.GetImageFromArray(source)
    source.SetSpacing(image_parameters)
    source.__SetPixelAsUInt16__
    source = np.reshape(source, [shape_source[0], shape_source[1]]) 
    
    target = sitk.GetImageFromArray(target)
    target.SetSpacing(image_parameters)
    target.__SetPixelAsUInt16__
    target = np.reshape(target, [shape_target[0], shape_target[1]])
    
    ## read the source and target images
    elastixImageFilter = itk.ElastixRegistrationMethod.New()
    elastixImageFilter.SetFixedImage(itk.GetImageFromArray(np.array(source, np.float32)))
    elastixImageFilter.SetMovingImage(itk.GetImageFromArray(np.array(target, np.float32)))

    ## call the parameter map file specifying the registration parameters
    if parallel == True: elastix_model_parameters = get_elastix_parameters_from_dictionary_parameters(elastix_model_parameters)
    elastixImageFilter.SetParameterObject(elastix_model_parameters)

    ## set additional options
    elastixImageFilter.SetNumberOfThreads(os.cpu_count()-1)
    
    # ITK-Elastix logging
    if log == True:
        elastixImageFilter.SetLogToConsole(True)
        print(&#34;Parameter Map: &#34;)
        print(elastix_model_parameters)
    else:
        elastixImageFilter.SetLogToConsole(False)

    ## update filter object (required)
    elastixImageFilter.UpdateLargestPossibleRegion()

    ## RUN ELASTIX using ITK-Elastix filters
    coregistered = itk.GetArrayFromImage(elastixImageFilter.GetOutput()).flatten()

    transformixImageFilter = itk.TransformixFilter.New()
    transformixImageFilter.SetTransformParameterObject(elastixImageFilter.GetTransformParameterObject())
    transformixImageFilter.ComputeDeformationFieldOn()
    transformixImageFilter.SetMovingImage(itk.GetImageFromArray(np.array(target, np.float32)))
    deformation_field = itk.GetArrayFromImage(transformixImageFilter.GetOutputDeformationField()).flatten()
    deformation_field = np.reshape(deformation_field, [int(len(deformation_field)/2), 2])

    return coregistered, deformation_field</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="MDR.MDR.fit_coregistration"><code class="name flex">
<span>def <span class="ident">fit_coregistration</span></span>(<span>fit, images, image_parameters, elastix_model_parameters, parallel=False, log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Co-register the 2D fit-image with the unregistered 2D input image.</p>
<h2 id="args">Args:</h2>
<p>fit (numpy.ndarray): signal model fit images (single 2D slice with all time-series) with shape: [x-dim,y-dim, total timeseries]<br>
images (numpy.ndarray): unregistered 2D images (uint16, single 2D slice with all time-series) as np-array with shape [x-dim,y-dim, total timeseries]<br>
image_parameters (sitk tuple): distance between pixels (in mm) along each dimension<br>
elastix_model_parameters (itk-elastix.ParameterObject): elastix file registration parameters
parallel (bool, optional): This flag determines if the co-registration is ran on 1 ('False', default) or multiple CPU cores ('True').
log (bool, optional): Default of this flag is 'True' and it prints the ITK-Elastix output in the terminal.</p>
<h2 id="returns">Returns:</h2>
<p>coregistered (numpy.ndarray): coregisterd 2D images with shape [x-dim * y-dim, total time-series]<br>
deformation_field (numpy.ndarray): output 2D deformation fields with shape [x-dim, y-dim, 2, num of dynamics].<br>
Dimension '2' corresponds to deformation_field_x and deformation_field_y.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_coregistration(fit, images, image_parameters, elastix_model_parameters, parallel = False, log = True):
    &#34;&#34;&#34;Co-register the 2D fit-image with the unregistered 2D input image.

    Args:
    ----
    fit (numpy.ndarray): signal model fit images (single 2D slice with all time-series) with shape: [x-dim,y-dim, total timeseries]  
    images (numpy.ndarray): unregistered 2D images (uint16, single 2D slice with all time-series) as np-array with shape [x-dim,y-dim, total timeseries]  
    image_parameters (sitk tuple): distance between pixels (in mm) along each dimension  
    elastix_model_parameters (itk-elastix.ParameterObject): elastix file registration parameters
    parallel (bool, optional): This flag determines if the co-registration is ran on 1 (&#39;False&#39;, default) or multiple CPU cores (&#39;True&#39;).
    log (bool, optional): Default of this flag is &#39;True&#39; and it prints the ITK-Elastix output in the terminal.

    Returns:
    -------
    coregistered (numpy.ndarray): coregisterd 2D images with shape [x-dim * y-dim, total time-series]  
    deformation_field (numpy.ndarray): output 2D deformation fields with shape [x-dim, y-dim, 2, num of dynamics].  
    Dimension &#39;2&#39; corresponds to deformation_field_x and deformation_field_y.  
    &#34;&#34;&#34;
    shape = np.shape(images)
    coregistered = np.empty((shape[0]*shape[1],shape[2]))
    deformation_field = np.empty([shape[0]*shape[1], 2, shape[2]])
    if parallel == False:
        for t in tqdm(range(shape[2]), desc=&#39;Co-registration progress&#39;): #dynamics
            coregistered[:,t], deformation_field[:,:,t] = itkElastix_MDR_coregistration(images[:,:,t], fit[:,:,t], elastix_model_parameters, image_parameters, parallel=False, log=log)
    else:
        pool = multiprocessing.Pool(processes=os.cpu_count()-1)
        dict_param = get_dictionary_parameters_from_elastix_parameters(elastix_model_parameters)
        arguments = [(t, images, fit, dict_param, image_parameters, log) for t in range(shape[2])] #dynamics
        results = list(tqdm(pool.imap(parallel_MDR_coregistration, arguments), total=shape[2], desc=&#39;Co-registration progress&#39;))
        for i, result in enumerate(results):
            coregistered[:, i] = result[0]
            deformation_field[:, :, i] = result[1]
    return coregistered, deformation_field</code></pre>
</details>
</dd>
<dt id="MDR.MDR.fit_signal_model_image"><code class="name flex">
<span>def <span class="ident">fit_signal_model_image</span></span>(<span>time_curve, model, signal_model_parameters, function='main')</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes signal time curve, signal model parameters, and model fit function name as input
and returns the fitted signal and associated output model parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_signal_model_image(time_curve, model, signal_model_parameters, function=&#39;main&#39;): 
    &#34;&#34;&#34;
        This function takes signal time curve, signal model parameters, and model fit function name as input 
        and returns the fitted signal and associated output model parameters.
    &#34;&#34;&#34;
    fit, fitted_parameters = getattr(model, function)(time_curve, signal_model_parameters)
    return fit, fitted_parameters</code></pre>
</details>
</dd>
<dt id="MDR.MDR.get_dictionary_parameters_from_elastix_parameters"><code class="name flex">
<span>def <span class="ident">get_dictionary_parameters_from_elastix_parameters</span></span>(<span>elastix_model_parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>This function converts the non-pickable object elastix_model_parameters and converts it into a list of dictionaries.
This is only called when parallel=True and the purpose is to make the multiprocessing possible and successful.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dictionary_parameters_from_elastix_parameters(elastix_model_parameters):
    &#34;&#34;&#34;
        This function converts the non-pickable object elastix_model_parameters and converts it into a list of dictionaries.
        This is only called when parallel=True and the purpose is to make the multiprocessing possible and successful.
    &#34;&#34;&#34;
    list_dictionaries_parameters = []
    for index in range(elastix_model_parameters.GetNumberOfParameterMaps()):
        parameter_map = elastix_model_parameters.GetParameterMap(index)
        one_parameter_map_dict = {}
        for i in parameter_map:
            one_parameter_map_dict[i] = parameter_map[i]
        list_dictionaries_parameters.append(one_parameter_map_dict)
    return list_dictionaries_parameters</code></pre>
</details>
</dd>
<dt id="MDR.MDR.get_elastix_parameters_from_dictionary_parameters"><code class="name flex">
<span>def <span class="ident">get_elastix_parameters_from_dictionary_parameters</span></span>(<span>list_dictionaries_parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>This function converts the list of dictionaries to the non-pickable object elastix_model_parameters during the itkElastix_MDR_coregistration processing.
This is only called when parallel=True and the purpose is to make the multiprocessing possible and successful.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elastix_parameters_from_dictionary_parameters(list_dictionaries_parameters):
    &#34;&#34;&#34;
        This function converts the list of dictionaries to the non-pickable object elastix_model_parameters during the itkElastix_MDR_coregistration processing.
        This is only called when parallel=True and the purpose is to make the multiprocessing possible and successful.
    &#34;&#34;&#34;
    elastix_model_parameters = itk.ParameterObject.New()
    for one_map in list_dictionaries_parameters:
        elastix_model_parameters.AddParameterMap(one_map)
    return elastix_model_parameters</code></pre>
</details>
</dd>
<dt id="MDR.MDR.itkElastix_MDR_coregistration"><code class="name flex">
<span>def <span class="ident">itkElastix_MDR_coregistration</span></span>(<span>target, source, elastix_model_parameters, image_parameters, parallel=False, log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>This function takes pair-wise unregistered source image and target image (per time-series point) as input
and returns ffd based co-registered target image and its corresponding deformation field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def itkElastix_MDR_coregistration(target, source, elastix_model_parameters, image_parameters, parallel = False, log = True):
    &#34;&#34;&#34;
        This function takes pair-wise unregistered source image and target image (per time-series point) as input 
        and returns ffd based co-registered target image and its corresponding deformation field. 
    &#34;&#34;&#34;
    shape_source = np.shape(source)
    shape_target = np.shape(target)

    source = sitk.GetImageFromArray(source)
    source.SetSpacing(image_parameters)
    source.__SetPixelAsUInt16__
    source = np.reshape(source, [shape_source[0], shape_source[1]]) 
    
    target = sitk.GetImageFromArray(target)
    target.SetSpacing(image_parameters)
    target.__SetPixelAsUInt16__
    target = np.reshape(target, [shape_target[0], shape_target[1]])
    
    ## read the source and target images
    elastixImageFilter = itk.ElastixRegistrationMethod.New()
    elastixImageFilter.SetFixedImage(itk.GetImageFromArray(np.array(source, np.float32)))
    elastixImageFilter.SetMovingImage(itk.GetImageFromArray(np.array(target, np.float32)))

    ## call the parameter map file specifying the registration parameters
    if parallel == True: elastix_model_parameters = get_elastix_parameters_from_dictionary_parameters(elastix_model_parameters)
    elastixImageFilter.SetParameterObject(elastix_model_parameters)

    ## set additional options
    elastixImageFilter.SetNumberOfThreads(os.cpu_count()-1)
    
    # ITK-Elastix logging
    if log == True:
        elastixImageFilter.SetLogToConsole(True)
        print(&#34;Parameter Map: &#34;)
        print(elastix_model_parameters)
    else:
        elastixImageFilter.SetLogToConsole(False)

    ## update filter object (required)
    elastixImageFilter.UpdateLargestPossibleRegion()

    ## RUN ELASTIX using ITK-Elastix filters
    coregistered = itk.GetArrayFromImage(elastixImageFilter.GetOutput()).flatten()

    transformixImageFilter = itk.TransformixFilter.New()
    transformixImageFilter.SetTransformParameterObject(elastixImageFilter.GetTransformParameterObject())
    transformixImageFilter.ComputeDeformationFieldOn()
    transformixImageFilter.SetMovingImage(itk.GetImageFromArray(np.array(target, np.float32)))
    deformation_field = itk.GetArrayFromImage(transformixImageFilter.GetOutputDeformationField()).flatten()
    deformation_field = np.reshape(deformation_field, [int(len(deformation_field)/2), 2])

    return coregistered, deformation_field</code></pre>
</details>
</dd>
<dt id="MDR.MDR.maximum_deformation_per_pixel"><code class="name flex">
<span>def <span class="ident">maximum_deformation_per_pixel</span></span>(<span>deformation_field, new_deformation_field)</span>
</code></dt>
<dd>
<div class="desc"><p>This function calculates diagnostics from the registration process.</p>
<p>It takes as input the original deformation field and the new deformation field
and returns the maximum deformation per pixel (in mm).
The maximum deformation per pixel is calculated as
the euclidean distance of difference between the old and new deformation field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maximum_deformation_per_pixel(deformation_field, new_deformation_field):
    &#34;&#34;&#34;This function calculates diagnostics from the registration process.

    It takes as input the original deformation field and the new deformation field
    and returns the maximum deformation per pixel (in mm).
    The maximum deformation per pixel is calculated as 
    the euclidean distance of difference between the old and new deformation field. 
    &#34;&#34;&#34;

    df_difference = deformation_field - new_deformation_field
    df_difference_x_squared = np.square(df_difference[:,0,:].squeeze())
    df_difference_y_squared = np.square(df_difference[:,1,:].squeeze())
    dist = np.sqrt(np.add(df_difference_x_squared, df_difference_y_squared))
    maximum_deformation_per_pixel = np.nanmax(dist)
    
    return maximum_deformation_per_pixel</code></pre>
</details>
</dd>
<dt id="MDR.MDR.model_driven_registration"><code class="name flex">
<span>def <span class="ident">model_driven_registration</span></span>(<span>images, image_parameters, model, signal_model_parameters, elastix_model_parameters, precision=1, function='main', parallel=False, log=True)</span>
</code></dt>
<dd>
<div class="desc"><p>main function that performs the model driven registration.</p>
<h2 id="args">Args:</h2>
<pre><code>images (numpy.ndarray): unregistered 2D images (uint16) from the selected single MR slice with shape [x-dim, y-dim, total timeseries].     
image_parameters (sitk tuple): distance between pixels (in mm) along each dimension.    
model (module): import module for the signal model to fit.    
signal_model_parameters (list()): list consisting of signal model input parameters.   
eg: TE (echo times) as input parameter (independent variable) for T2*sequence model fit.    
elastix_model_parameters (itk-elastix.ParameterObject): elastix file registration parameters.    
precision (int, optional): precision (in mm) to define the convergence criterion for MDR. Defaults to 1. Lower value means higher precision.    
function (string, optional): name (user-defined) of the main model-fit function. Default is 'main'.
parallel (bool, optional): This flag determines if the co-registration is ran on 1 ('False', default) or multiple CPU cores ('True').
log (bool, optional): Default of this flag is 'True' and it prints the ITK-Elastix output in the terminal.
</code></pre>
<h2 id="returns">Returns:</h2>
<pre><code>coregistered (numpy.ndarray): ffd based co-registered (uint16) 2D images as np-array with shape: [x-dim,y-dim,  total time-series] of the selected input MR slice  
fit (numpy.ndarray): signal model fit images (uint16) of specified MR slice with shape [x-dim,y-dim,  total time-series]  
deformation_field (numpy.ndarray): output 2D deformation fields, 'deformation_field_x' and 'deformation_field_y' as np-array with shape [x-dim, y-dim, 2,  total timeseries]  
par (numpy.ndarray): signal model-fit output parameters  
improvement (dataframe): maximum deformation per pixel calculated as the euclidean distance of difference between old and new deformation field appended to a dataframe until convergence criterion is met.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_driven_registration(images, image_parameters, model, signal_model_parameters, elastix_model_parameters, precision = 1,  function = &#39;main&#39;, parallel = False, log = True): 
    &#34;&#34;&#34; main function that performs the model driven registration.

    Args:
    ----
        images (numpy.ndarray): unregistered 2D images (uint16) from the selected single MR slice with shape [x-dim, y-dim, total timeseries].     
        image_parameters (sitk tuple): distance between pixels (in mm) along each dimension.    
        model (module): import module for the signal model to fit.    
        signal_model_parameters (list()): list consisting of signal model input parameters.   
        eg: TE (echo times) as input parameter (independent variable) for T2*sequence model fit.    
        elastix_model_parameters (itk-elastix.ParameterObject): elastix file registration parameters.    
        precision (int, optional): precision (in mm) to define the convergence criterion for MDR. Defaults to 1. Lower value means higher precision.    
        function (string, optional): name (user-defined) of the main model-fit function. Default is &#39;main&#39;.
        parallel (bool, optional): This flag determines if the co-registration is ran on 1 (&#39;False&#39;, default) or multiple CPU cores (&#39;True&#39;).
        log (bool, optional): Default of this flag is &#39;True&#39; and it prints the ITK-Elastix output in the terminal.
    
    Returns:
    -------
        coregistered (numpy.ndarray): ffd based co-registered (uint16) 2D images as np-array with shape: [x-dim,y-dim,  total time-series] of the selected input MR slice  
        fit (numpy.ndarray): signal model fit images (uint16) of specified MR slice with shape [x-dim,y-dim,  total time-series]  
        deformation_field (numpy.ndarray): output 2D deformation fields, &#39;deformation_field_x&#39; and &#39;deformation_field_y&#39; as np-array with shape [x-dim, y-dim, 2,  total timeseries]  
        par (numpy.ndarray): signal model-fit output parameters  
        improvement (dataframe): maximum deformation per pixel calculated as the euclidean distance of difference between old and new deformation field appended to a dataframe until convergence criterion is met.
    &#34;&#34;&#34;
 
    shape = np.shape(images)
    improvement = []  

    # Initialise the solution
    coregistered = copy.deepcopy(images) 
    coregistered =  np.reshape(coregistered,(shape[0]*shape[1],shape[2]))
    deformation_field = np.empty((shape[0]*shape[1],2,shape[2]))

    converged = False
    while not converged: 

        # Update the solution
        fit, par = fit_signal_model_image(coregistered, model, signal_model_parameters, function=function)
        fit = np.reshape(fit,(shape[0],shape[1],shape[2]))
        # perform 2D image registration
        coregistered, new_deformation_field = fit_coregistration(fit, images, image_parameters, elastix_model_parameters, parallel=parallel, log=log)
        # check convergence    
        improvement.append(maximum_deformation_per_pixel(deformation_field, new_deformation_field))
        converged = improvement[-1] &lt;= precision           
        deformation_field = new_deformation_field

    coregistered = np.reshape(coregistered,(shape[0],shape[1],shape[2]))
    deformation_field = np.reshape(deformation_field,(shape[0],shape[1],2,shape[2])) 
    improvement = pd.DataFrame({&#39;maximum_deformation_per_pixel&#39;: improvement}) 

    return coregistered, fit, deformation_field, par, improvement</code></pre>
</details>
</dd>
<dt id="MDR.MDR.parallel_MDR_coregistration"><code class="name flex">
<span>def <span class="ident">parallel_MDR_coregistration</span></span>(<span>parallel_arguments)</span>
</code></dt>
<dd>
<div class="desc"><p>This function calls itkElastix_MDR_coregistration when parallel=True.
It runs and distributes the mentioned function to multiple cores.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parallel_MDR_coregistration(parallel_arguments):
    &#34;&#34;&#34;
        This function calls itkElastix_MDR_coregistration when parallel=True. 
        It runs and distributes the mentioned function to multiple cores.
    &#34;&#34;&#34;
    t, images, fit, elastix_model_parameters, image_parameters, log = parallel_arguments
    coregistered_t, deformation_field_t = itkElastix_MDR_coregistration(images[:,:,t], fit[:,:,t], elastix_model_parameters, image_parameters, parallel=True, log=log)
    return coregistered_t, deformation_field_t</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MDR" href="index.html">MDR</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="MDR.MDR.fit_coregistration" href="#MDR.MDR.fit_coregistration">fit_coregistration</a></code></li>
<li><code><a title="MDR.MDR.fit_signal_model_image" href="#MDR.MDR.fit_signal_model_image">fit_signal_model_image</a></code></li>
<li><code><a title="MDR.MDR.get_dictionary_parameters_from_elastix_parameters" href="#MDR.MDR.get_dictionary_parameters_from_elastix_parameters">get_dictionary_parameters_from_elastix_parameters</a></code></li>
<li><code><a title="MDR.MDR.get_elastix_parameters_from_dictionary_parameters" href="#MDR.MDR.get_elastix_parameters_from_dictionary_parameters">get_elastix_parameters_from_dictionary_parameters</a></code></li>
<li><code><a title="MDR.MDR.itkElastix_MDR_coregistration" href="#MDR.MDR.itkElastix_MDR_coregistration">itkElastix_MDR_coregistration</a></code></li>
<li><code><a title="MDR.MDR.maximum_deformation_per_pixel" href="#MDR.MDR.maximum_deformation_per_pixel">maximum_deformation_per_pixel</a></code></li>
<li><code><a title="MDR.MDR.model_driven_registration" href="#MDR.MDR.model_driven_registration">model_driven_registration</a></code></li>
<li><code><a title="MDR.MDR.parallel_MDR_coregistration" href="#MDR.MDR.parallel_MDR_coregistration">parallel_MDR_coregistration</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>