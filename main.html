<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mdreg.main API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mdreg.main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import time, os, copy
import multiprocessing
from tqdm import tqdm
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import itk
import SimpleITK as sitk

from .models import constant

default_path = os.path.dirname(__file__)

class MDReg:

    def __init__(self):

        # input
        self.array = None
        self.signal_parameters = None
        self.pixel_spacing = 1.0
        self.signal_model = constant
        self.elastix = _default_bspline()

        # mdr optimization
        self.max_iterations = 5
        self.precision = 1.0

        # output
        self.coreg = None
        self.model_fit = None
        self.deformation = None
        self.pars = None
        self.iter = None
        self.export_path = os.path.join(default_path, &#39;results&#39;)
        self.export_unregistered = True

    @property
    def _npdt(self): 
        &#34;&#34;&#34;
        (nr of pixels, nr of dimensions, nr of time points)
        &#34;&#34;&#34;
        shape = self.array.shape  
        return np.prod(shape[:-1]), len(shape)-1, shape[-1]

    def set_array(self, array):
        self.array = array
        self.coreg = array
        n = self._npdt
        self.coreg = np.reshape(self.coreg, (n[0],n[2]))

    def read_elastix(self, file):
        self.elastix.AddParameterFile(file)
    
    def set_elastix(self, **kwargs):
        for tag, value in kwargs.items():
            self.elastix.SetParameter(tag, str(value))       

    def fit(self):

        n = self._npdt
        self.coreg = copy.deepcopy(self.array)
        self.coreg = np.reshape(self.coreg, (n[0],n[2]))
        self.deformation = np.zeros(n)
        start = time.time()
        improvement = []
        converged = False
        it = 1
        while not converged: 
            startit = time.time()
            print(&#39;Starting MDR iteration &#39; + str(it))
            self.fit_signal()
            if self.export_unregistered:
                if it == 1: self.export_fit(name=&#39;_unregistered&#39;)
            deformation = self.fit_deformation()
            improvement.append(_maxnorm(self.deformation-deformation))
            self.deformation = deformation
            converged = improvement[-1] &lt;= self.precision 
            if it == self.max_iterations: converged=True
            calctime = (time.time()-startit)/60
            print(&#39;Finished MDR iteration &#39; + str(it) + &#39; after &#39; + str(calctime) + &#39; min&#39;) 
            print(&#39;Improvement after MDR iteration &#39; + str(it) + &#39;: &#39; + str(improvement[-1]) + &#39; pixels&#39;)  
            it += 1       
        self.fit_signal()
        shape = self.array.shape
        self.coreg = np.reshape(self.coreg, shape)
        nd = len(shape)-1
        self.deformation = np.reshape(self.deformation, shape[:-1]+(nd,)+(shape[-1],))
        self.iter = pd.DataFrame({&#39;Maximum deformation&#39;: improvement}) 

        print(&#39;Calculation time: &#39; + str((time.time()-start)/60) + &#39; min&#39;)

    def fit_signal(self):

        start = time.time()
        print(&#39;Fitting signal model..&#39;)
        fit, pars = self.signal_model.main(self.coreg, self.signal_parameters)
        shape = self.array.shape
        self.model_fit = np.reshape(fit, shape)
        self.pars = np.reshape(pars, shape[:-1] + (pars.shape[-1],))
        print(&#39;Finished fitting signal model (&#39; + str((time.time()-start)/60) + &#39; min)&#39;)

    def fit_deformation(self, parallel=True, log=False, mask=None):

        start = time.time()
        print(&#39;Performing coregistration..&#39;)
        nt = self._npdt[-1]
        deformation = np.empty(self._npdt)
        dict_param = _elastix2dict(self.elastix) # Hack necessary for parallelization
        # If mask isn&#39;t same shape as images, then don&#39;t use it
        if isinstance(mask, np.ndarray):
            if np.shape(mask) != self.array.shape: mask = None  
        if not parallel:
            for t in tqdm(range(nt), desc=&#39;Coregistration progress&#39;): #dynamics
                if mask is not None: 
                    mask_t = mask[...,t]
                else: 
                    mask_t = None
                args = (self.array[...,t], self.model_fit[...,t], dict_param, self.pixel_spacing, log, mask_t)
                self.coreg[:,t], deformation[:,:,t] = _coregister(args)
        else:
            pool = multiprocessing.Pool(processes=os.cpu_count()-1)
            if mask is None:
                args = [(self.array[...,t], self.model_fit[...,t], dict_param, self.pixel_spacing, log, mask) for t in range(nt)] #dynamics
            else:
                args = [(self.array[...,t], self.model_fit[...,t], dict_param, self.pixel_spacing, log, mask[...,t]) for t in range(nt)] #dynamics
            results = list(tqdm(pool.imap(_coregister, args), total=nt, desc=&#39;Coregistration progress&#39;))
            for t in range(nt):
                self.coreg[:,t] = results[t][0]
                deformation[:,:,t] = results[t][1]
        print(&#39;Finished coregistration (&#39; + str((time.time()-start)/60) +&#39; min)&#39;)
        return deformation

    def export(self):

        self.export_data()
        self.export_fit()
        self.export_registered()

    def export_data(self):

        print(&#39;Exporting data..&#39;)
        path = self.export_path 
        if not os.path.exists(path): os.mkdir(path)
        _export_animation(self.array, path, &#39;images&#39;)

    def export_fit(self, name=&#39;&#39;):

        print(&#39;Exporting fit..&#39; + name)
        path = self.export_path 
        pars = self.signal_model.pars()
        if not os.path.exists(path): os.mkdir(path)
        lower, upper = self.signal_model.bounds()
        for i in range(len(pars)):
            _export_imgs(self.pars[...,i], path, pars[i] + name, bounds=[lower[i],upper[i]])
        _export_animation(self.model_fit, path, &#39;modelfit&#39; + name)

    def export_registered(self):

        print(&#39;Exporting registration..&#39;)
        path = self.export_path 
        if not os.path.exists(path): os.mkdir(path)
        defx = np.squeeze(self.deformation[:,:,0,:])
        defy = np.squeeze(self.deformation[:,:,1,:])
        _export_animation(self.coreg, path, &#39;coregistered&#39;)
        _export_animation(defx, path, &#39;deformation_field_x&#39;)
        _export_animation(defy, path, &#39;deformation_field_y&#39;)
        _export_animation(np.sqrt(defx**2 + defy**2), path, &#39;deformation_field&#39;)
        self.iter.to_csv(os.path.join(path, &#39;largest_deformations.csv&#39;))


def _default_bspline():
    param_obj = itk.ParameterObject.New()
    parameter_map_bspline = param_obj.GetDefaultParameterMap(&#39;bspline&#39;)
    param_obj.AddParameterMap(parameter_map_bspline)
    param_obj.SetParameter(&#34;FixedInternalImagePixelType&#34;, &#34;float&#34;)
    param_obj.SetParameter(&#34;MovingInternalImagePixelType&#34;, &#34;float&#34;)
    param_obj.SetParameter(&#34;FixedImageDimension&#34;, &#34;2&#34;)
    param_obj.SetParameter(&#34;MovingImageDimension&#34;, &#34;2&#34;)
    param_obj.SetParameter(&#34;UseDirectionCosines&#34;, &#34;true&#34;)
    param_obj.SetParameter(&#34;Registration&#34;, &#34;MultiResolutionRegistration&#34;)
    param_obj.SetParameter(&#34;ImageSampler&#34;, &#34;RandomCoordinate&#34;)
    param_obj.SetParameter(&#34;Interpolator&#34;, &#34;BSplineInterpolator&#34;)
    param_obj.SetParameter(&#34;ResampleInterpolator&#34;, &#34;FinalBSplineInterpolator&#34;)
    param_obj.SetParameter(&#34;Resampler&#34;, &#34;DefaultResampler&#34;)
    param_obj.SetParameter(&#34;BSplineInterpolationOrder&#34;, &#34;1&#34;)
    param_obj.SetParameter(&#34;FinalBSplineInterpolationOrder&#34;, &#34;1&#34;)
    param_obj.SetParameter(&#34;FixedImagePyramid&#34;, &#34;FixedSmoothingImagePyramid&#34;)
    param_obj.SetParameter(&#34;MovingImagePyramid&#34;, &#34;MovingSmoothingImagePyramid&#34;)
    param_obj.SetParameter(&#34;Optimizer&#34;, &#34;AdaptiveStochasticGradientDescent&#34;)
    param_obj.SetParameter(&#34;HowToCombineTransforms&#34;, &#34;Compose&#34;)
    param_obj.SetParameter(&#34;Transform&#34;, &#34;BSplineTransform&#34;)
    param_obj.SetParameter(&#34;Metric&#34;, &#34;AdvancedMeanSquares&#34;)
    param_obj.SetParameter(&#34;NumberOfHistogramBins&#34;, &#34;32&#34;)
    param_obj.SetParameter(&#34;FinalGridSpacingInPhysicalUnits&#34;, [&#34;50.0&#34;, &#34;50.0&#34;])
    param_obj.SetParameter(&#34;NumberOfResolutions&#34;, &#34;4&#34;)
    param_obj.SetParameter(&#34;AutomaticParameterEstimation&#34;, &#34;true&#34;)
    param_obj.SetParameter(&#34;ASGDParameterEstimationMethod&#34;, &#34;Original&#34;)
    param_obj.SetParameter(&#34;MaximumNumberOfIterations&#34;, &#34;500&#34;)
    param_obj.SetParameter(&#34;MaximumStepLength&#34;, &#34;0.1&#34;)
    param_obj.SetParameter(&#34;NumberOfSpatialSamples&#34;, &#34;2048&#34;)
    param_obj.SetParameter(&#34;NewSamplesEveryIteration&#34;, &#34;true&#34;)
    param_obj.SetParameter(&#34;CheckNumberOfSamples&#34;, &#34;true&#34;)
    param_obj.SetParameter(&#34;ErodeMask&#34;, &#34;false&#34;)
    param_obj.SetParameter(&#34;ErodeFixedMask&#34;, &#34;false&#34;)
    param_obj.SetParameter(&#34;DefaultPixelValue&#34;, &#34;0&#34;)
    param_obj.SetParameter(&#34;WriteResultImage&#34;, &#34;true&#34;)
    param_obj.SetParameter(&#34;ResultImagePixelType&#34;, &#34;float&#34;)
    param_obj.SetParameter(&#34;ResultImageFormat&#34;, &#34;mhd&#34;)
    return param_obj


def _export_animation(array, path, filename):

    file = os.path.join(path, filename + &#39;.gif&#39;)
    array[np.isnan(array)] = 0
    fig = plt.figure()
    im = plt.imshow(np.squeeze(array[:,:,0]).T, animated=True)
    def updatefig(i):
        im.set_array(np.squeeze(array[:,:,i]).T)
    anim = animation.FuncAnimation(fig, updatefig, interval=50, frames=array.shape[2])
    anim.save(file)
    #plt.show()


def _export_imgs(array, path, filename, bounds=[-np.inf, np.inf]):

    file = os.path.join(path, filename + &#39;.png&#39;)
    array[np.isnan(array)] = 0
    array[np.isinf(array)] = 0
    array = np.clip(array, bounds[0], bounds[1])
    plt.imshow(array.T)
    plt.clim(np.amin(array), np.amax(array))
    cBar = plt.colorbar()
    cBar.minorticks_on()
    plt.savefig(fname=file)
    plt.close()


def _maxnorm(d):
    &#34;&#34;&#34;This function calculates diagnostics from the registration process.

    It takes as input the original deformation field and the new deformation field
    and returns the maximum deformation per pixel (in mm).
    The maximum deformation per pixel is calculated as 
    the euclidean distance of difference between the old and new deformation field. 
    &#34;&#34;&#34;
    d = d[:,0,:]**2 + d[:,1,:]**2
    return np.nanmax(np.sqrt(d))


def _elastix2dict(elastix_model_parameters):
    &#34;&#34;&#34;
    Hack to allow parallel processing
    &#34;&#34;&#34;
    list_dictionaries_parameters = []
    for index in range(elastix_model_parameters.GetNumberOfParameterMaps()):
        parameter_map = elastix_model_parameters.GetParameterMap(index)
        one_parameter_map_dict = {}
        for i in parameter_map:
            one_parameter_map_dict[i] = parameter_map[i]
        list_dictionaries_parameters.append(one_parameter_map_dict)
    return list_dictionaries_parameters


def _dict2elastix(list_dictionaries_parameters):
    &#34;&#34;&#34;
    Hack to allow parallel processing
    &#34;&#34;&#34;
    elastix_model_parameters = itk.ParameterObject.New()
    for one_map in list_dictionaries_parameters:
        elastix_model_parameters.AddParameterMap(one_map)
    return elastix_model_parameters


def _coregister(args):
    &#34;&#34;&#34;
    Coregister two arrays and return coregistered + deformation field 
    &#34;&#34;&#34;
    target, source, elastix_model_parameters, spacing, log, mask = args
    shape_source = np.shape(source)
    shape_target = np.shape(target)

    source = sitk.GetImageFromArray(source)
    source.SetSpacing(spacing)
    source.__SetPixelAsUInt16__
    source = np.nan_to_num(np.reshape(source, [shape_source[0], shape_source[1]]))
    
    target = sitk.GetImageFromArray(target)
    target.SetSpacing(spacing)
    target.__SetPixelAsUInt16__
    target = np.nan_to_num(np.reshape(target, [shape_target[0], shape_target[1]]))
    
    ## read the source and target images
    elastixImageFilter = itk.ElastixRegistrationMethod.New()
    elastixImageFilter.SetFixedImage(itk.GetImageFromArray(np.array(source, np.float32)))
    elastixImageFilter.SetMovingImage(itk.GetImageFromArray(np.array(target, np.float32)))
    if mask is not None:
        shape_mask = np.shape(mask)
        mask = sitk.GetImageFromArray(mask)
        mask.SetSpacing(spacing)
        mask.__SetPixelAsUInt8__
        mask = np.nan_to_num(np.reshape(mask, [shape_mask[0], shape_mask[1]]))
        elastixImageFilter.SetFixedMask(itk.GetImageFromArray(np.array(mask, np.uint8)))
        elastixImageFilter.SetMovingMask(itk.GetImageFromArray(np.array(mask, np.uint8)))

    ## call the parameter map file specifying the registration parameters
    elastix_model_parameters = _dict2elastix(elastix_model_parameters) # Hack
    elastixImageFilter.SetParameterObject(elastix_model_parameters)

    ## set additional options
    elastixImageFilter.SetNumberOfThreads(os.cpu_count()-1)
    
    # logging; note that nothing is printed in Jupyter Notebooks
    elastixImageFilter.SetLogToFile(log)
    elastixImageFilter.SetLogToConsole(log)
    if log == True:
        print(&#34;Parameter Map: &#34;)
        print(elastix_model_parameters)
        output_dir = os.path.join(os.getcwd(), &#34;Elastix Log&#34;)
        os.makedirs(output_dir, exist_ok=True)
        #log_filename = &#34;ITK-Elastix.log&#34;
        i = 0
        while os.path.exists(os.path.join(output_dir, f&#34;ITK-Elastix_{i}.log&#34;)): i += 1
        log_filename = f&#34;ITK-Elastix_{i}.log&#34;
        elastixImageFilter.SetOutputDirectory(output_dir)
        elastixImageFilter.SetLogFileName(log_filename)

    ## update filter object (required)
    elastixImageFilter.UpdateLargestPossibleRegion()

    ## RUN ELASTIX using ITK-Elastix filters
    coregistered = itk.GetArrayFromImage(elastixImageFilter.GetOutput()).flatten()

    transformixImageFilter = itk.TransformixFilter.New()
    transformixImageFilter.SetTransformParameterObject(elastixImageFilter.GetTransformParameterObject())
    transformixImageFilter.ComputeDeformationFieldOn()
    transformixImageFilter.SetMovingImage(itk.GetImageFromArray(np.array(target, np.float32)))
    deformation_field = itk.GetArrayFromImage(transformixImageFilter.GetOutputDeformationField()).flatten()
    deformation_field = np.reshape(deformation_field, [int(len(deformation_field)/2), 2])

    return coregistered, deformation_field</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mdreg.main.MDReg"><code class="flex name class">
<span>class <span class="ident">MDReg</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MDReg:

    def __init__(self):

        # input
        self.array = None
        self.signal_parameters = None
        self.pixel_spacing = 1.0
        self.signal_model = constant
        self.elastix = _default_bspline()

        # mdr optimization
        self.max_iterations = 5
        self.precision = 1.0

        # output
        self.coreg = None
        self.model_fit = None
        self.deformation = None
        self.pars = None
        self.iter = None
        self.export_path = os.path.join(default_path, &#39;results&#39;)
        self.export_unregistered = True

    @property
    def _npdt(self): 
        &#34;&#34;&#34;
        (nr of pixels, nr of dimensions, nr of time points)
        &#34;&#34;&#34;
        shape = self.array.shape  
        return np.prod(shape[:-1]), len(shape)-1, shape[-1]

    def set_array(self, array):
        self.array = array
        self.coreg = array
        n = self._npdt
        self.coreg = np.reshape(self.coreg, (n[0],n[2]))

    def read_elastix(self, file):
        self.elastix.AddParameterFile(file)
    
    def set_elastix(self, **kwargs):
        for tag, value in kwargs.items():
            self.elastix.SetParameter(tag, str(value))       

    def fit(self):

        n = self._npdt
        self.coreg = copy.deepcopy(self.array)
        self.coreg = np.reshape(self.coreg, (n[0],n[2]))
        self.deformation = np.zeros(n)
        start = time.time()
        improvement = []
        converged = False
        it = 1
        while not converged: 
            startit = time.time()
            print(&#39;Starting MDR iteration &#39; + str(it))
            self.fit_signal()
            if self.export_unregistered:
                if it == 1: self.export_fit(name=&#39;_unregistered&#39;)
            deformation = self.fit_deformation()
            improvement.append(_maxnorm(self.deformation-deformation))
            self.deformation = deformation
            converged = improvement[-1] &lt;= self.precision 
            if it == self.max_iterations: converged=True
            calctime = (time.time()-startit)/60
            print(&#39;Finished MDR iteration &#39; + str(it) + &#39; after &#39; + str(calctime) + &#39; min&#39;) 
            print(&#39;Improvement after MDR iteration &#39; + str(it) + &#39;: &#39; + str(improvement[-1]) + &#39; pixels&#39;)  
            it += 1       
        self.fit_signal()
        shape = self.array.shape
        self.coreg = np.reshape(self.coreg, shape)
        nd = len(shape)-1
        self.deformation = np.reshape(self.deformation, shape[:-1]+(nd,)+(shape[-1],))
        self.iter = pd.DataFrame({&#39;Maximum deformation&#39;: improvement}) 

        print(&#39;Calculation time: &#39; + str((time.time()-start)/60) + &#39; min&#39;)

    def fit_signal(self):

        start = time.time()
        print(&#39;Fitting signal model..&#39;)
        fit, pars = self.signal_model.main(self.coreg, self.signal_parameters)
        shape = self.array.shape
        self.model_fit = np.reshape(fit, shape)
        self.pars = np.reshape(pars, shape[:-1] + (pars.shape[-1],))
        print(&#39;Finished fitting signal model (&#39; + str((time.time()-start)/60) + &#39; min)&#39;)

    def fit_deformation(self, parallel=True, log=False, mask=None):

        start = time.time()
        print(&#39;Performing coregistration..&#39;)
        nt = self._npdt[-1]
        deformation = np.empty(self._npdt)
        dict_param = _elastix2dict(self.elastix) # Hack necessary for parallelization
        # If mask isn&#39;t same shape as images, then don&#39;t use it
        if isinstance(mask, np.ndarray):
            if np.shape(mask) != self.array.shape: mask = None  
        if not parallel:
            for t in tqdm(range(nt), desc=&#39;Coregistration progress&#39;): #dynamics
                if mask is not None: 
                    mask_t = mask[...,t]
                else: 
                    mask_t = None
                args = (self.array[...,t], self.model_fit[...,t], dict_param, self.pixel_spacing, log, mask_t)
                self.coreg[:,t], deformation[:,:,t] = _coregister(args)
        else:
            pool = multiprocessing.Pool(processes=os.cpu_count()-1)
            if mask is None:
                args = [(self.array[...,t], self.model_fit[...,t], dict_param, self.pixel_spacing, log, mask) for t in range(nt)] #dynamics
            else:
                args = [(self.array[...,t], self.model_fit[...,t], dict_param, self.pixel_spacing, log, mask[...,t]) for t in range(nt)] #dynamics
            results = list(tqdm(pool.imap(_coregister, args), total=nt, desc=&#39;Coregistration progress&#39;))
            for t in range(nt):
                self.coreg[:,t] = results[t][0]
                deformation[:,:,t] = results[t][1]
        print(&#39;Finished coregistration (&#39; + str((time.time()-start)/60) +&#39; min)&#39;)
        return deformation

    def export(self):

        self.export_data()
        self.export_fit()
        self.export_registered()

    def export_data(self):

        print(&#39;Exporting data..&#39;)
        path = self.export_path 
        if not os.path.exists(path): os.mkdir(path)
        _export_animation(self.array, path, &#39;images&#39;)

    def export_fit(self, name=&#39;&#39;):

        print(&#39;Exporting fit..&#39; + name)
        path = self.export_path 
        pars = self.signal_model.pars()
        if not os.path.exists(path): os.mkdir(path)
        lower, upper = self.signal_model.bounds()
        for i in range(len(pars)):
            _export_imgs(self.pars[...,i], path, pars[i] + name, bounds=[lower[i],upper[i]])
        _export_animation(self.model_fit, path, &#39;modelfit&#39; + name)

    def export_registered(self):

        print(&#39;Exporting registration..&#39;)
        path = self.export_path 
        if not os.path.exists(path): os.mkdir(path)
        defx = np.squeeze(self.deformation[:,:,0,:])
        defy = np.squeeze(self.deformation[:,:,1,:])
        _export_animation(self.coreg, path, &#39;coregistered&#39;)
        _export_animation(defx, path, &#39;deformation_field_x&#39;)
        _export_animation(defy, path, &#39;deformation_field_y&#39;)
        _export_animation(np.sqrt(defx**2 + defy**2), path, &#39;deformation_field&#39;)
        self.iter.to_csv(os.path.join(path, &#39;largest_deformations.csv&#39;))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mdreg.main.MDReg.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self):

    self.export_data()
    self.export_fit()
    self.export_registered()</code></pre>
</details>
</dd>
<dt id="mdreg.main.MDReg.export_data"><code class="name flex">
<span>def <span class="ident">export_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_data(self):

    print(&#39;Exporting data..&#39;)
    path = self.export_path 
    if not os.path.exists(path): os.mkdir(path)
    _export_animation(self.array, path, &#39;images&#39;)</code></pre>
</details>
</dd>
<dt id="mdreg.main.MDReg.export_fit"><code class="name flex">
<span>def <span class="ident">export_fit</span></span>(<span>self, name='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_fit(self, name=&#39;&#39;):

    print(&#39;Exporting fit..&#39; + name)
    path = self.export_path 
    pars = self.signal_model.pars()
    if not os.path.exists(path): os.mkdir(path)
    lower, upper = self.signal_model.bounds()
    for i in range(len(pars)):
        _export_imgs(self.pars[...,i], path, pars[i] + name, bounds=[lower[i],upper[i]])
    _export_animation(self.model_fit, path, &#39;modelfit&#39; + name)</code></pre>
</details>
</dd>
<dt id="mdreg.main.MDReg.export_registered"><code class="name flex">
<span>def <span class="ident">export_registered</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_registered(self):

    print(&#39;Exporting registration..&#39;)
    path = self.export_path 
    if not os.path.exists(path): os.mkdir(path)
    defx = np.squeeze(self.deformation[:,:,0,:])
    defy = np.squeeze(self.deformation[:,:,1,:])
    _export_animation(self.coreg, path, &#39;coregistered&#39;)
    _export_animation(defx, path, &#39;deformation_field_x&#39;)
    _export_animation(defy, path, &#39;deformation_field_y&#39;)
    _export_animation(np.sqrt(defx**2 + defy**2), path, &#39;deformation_field&#39;)
    self.iter.to_csv(os.path.join(path, &#39;largest_deformations.csv&#39;))</code></pre>
</details>
</dd>
<dt id="mdreg.main.MDReg.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self):

    n = self._npdt
    self.coreg = copy.deepcopy(self.array)
    self.coreg = np.reshape(self.coreg, (n[0],n[2]))
    self.deformation = np.zeros(n)
    start = time.time()
    improvement = []
    converged = False
    it = 1
    while not converged: 
        startit = time.time()
        print(&#39;Starting MDR iteration &#39; + str(it))
        self.fit_signal()
        if self.export_unregistered:
            if it == 1: self.export_fit(name=&#39;_unregistered&#39;)
        deformation = self.fit_deformation()
        improvement.append(_maxnorm(self.deformation-deformation))
        self.deformation = deformation
        converged = improvement[-1] &lt;= self.precision 
        if it == self.max_iterations: converged=True
        calctime = (time.time()-startit)/60
        print(&#39;Finished MDR iteration &#39; + str(it) + &#39; after &#39; + str(calctime) + &#39; min&#39;) 
        print(&#39;Improvement after MDR iteration &#39; + str(it) + &#39;: &#39; + str(improvement[-1]) + &#39; pixels&#39;)  
        it += 1       
    self.fit_signal()
    shape = self.array.shape
    self.coreg = np.reshape(self.coreg, shape)
    nd = len(shape)-1
    self.deformation = np.reshape(self.deformation, shape[:-1]+(nd,)+(shape[-1],))
    self.iter = pd.DataFrame({&#39;Maximum deformation&#39;: improvement}) 

    print(&#39;Calculation time: &#39; + str((time.time()-start)/60) + &#39; min&#39;)</code></pre>
</details>
</dd>
<dt id="mdreg.main.MDReg.fit_deformation"><code class="name flex">
<span>def <span class="ident">fit_deformation</span></span>(<span>self, parallel=True, log=False, mask=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_deformation(self, parallel=True, log=False, mask=None):

    start = time.time()
    print(&#39;Performing coregistration..&#39;)
    nt = self._npdt[-1]
    deformation = np.empty(self._npdt)
    dict_param = _elastix2dict(self.elastix) # Hack necessary for parallelization
    # If mask isn&#39;t same shape as images, then don&#39;t use it
    if isinstance(mask, np.ndarray):
        if np.shape(mask) != self.array.shape: mask = None  
    if not parallel:
        for t in tqdm(range(nt), desc=&#39;Coregistration progress&#39;): #dynamics
            if mask is not None: 
                mask_t = mask[...,t]
            else: 
                mask_t = None
            args = (self.array[...,t], self.model_fit[...,t], dict_param, self.pixel_spacing, log, mask_t)
            self.coreg[:,t], deformation[:,:,t] = _coregister(args)
    else:
        pool = multiprocessing.Pool(processes=os.cpu_count()-1)
        if mask is None:
            args = [(self.array[...,t], self.model_fit[...,t], dict_param, self.pixel_spacing, log, mask) for t in range(nt)] #dynamics
        else:
            args = [(self.array[...,t], self.model_fit[...,t], dict_param, self.pixel_spacing, log, mask[...,t]) for t in range(nt)] #dynamics
        results = list(tqdm(pool.imap(_coregister, args), total=nt, desc=&#39;Coregistration progress&#39;))
        for t in range(nt):
            self.coreg[:,t] = results[t][0]
            deformation[:,:,t] = results[t][1]
    print(&#39;Finished coregistration (&#39; + str((time.time()-start)/60) +&#39; min)&#39;)
    return deformation</code></pre>
</details>
</dd>
<dt id="mdreg.main.MDReg.fit_signal"><code class="name flex">
<span>def <span class="ident">fit_signal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_signal(self):

    start = time.time()
    print(&#39;Fitting signal model..&#39;)
    fit, pars = self.signal_model.main(self.coreg, self.signal_parameters)
    shape = self.array.shape
    self.model_fit = np.reshape(fit, shape)
    self.pars = np.reshape(pars, shape[:-1] + (pars.shape[-1],))
    print(&#39;Finished fitting signal model (&#39; + str((time.time()-start)/60) + &#39; min)&#39;)</code></pre>
</details>
</dd>
<dt id="mdreg.main.MDReg.read_elastix"><code class="name flex">
<span>def <span class="ident">read_elastix</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_elastix(self, file):
    self.elastix.AddParameterFile(file)</code></pre>
</details>
</dd>
<dt id="mdreg.main.MDReg.set_array"><code class="name flex">
<span>def <span class="ident">set_array</span></span>(<span>self, array)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_array(self, array):
    self.array = array
    self.coreg = array
    n = self._npdt
    self.coreg = np.reshape(self.coreg, (n[0],n[2]))</code></pre>
</details>
</dd>
<dt id="mdreg.main.MDReg.set_elastix"><code class="name flex">
<span>def <span class="ident">set_elastix</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_elastix(self, **kwargs):
    for tag, value in kwargs.items():
        self.elastix.SetParameter(tag, str(value))       </code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mdreg" href="index.html">mdreg</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mdreg.main.MDReg" href="#mdreg.main.MDReg">MDReg</a></code></h4>
<ul class="two-column">
<li><code><a title="mdreg.main.MDReg.export" href="#mdreg.main.MDReg.export">export</a></code></li>
<li><code><a title="mdreg.main.MDReg.export_data" href="#mdreg.main.MDReg.export_data">export_data</a></code></li>
<li><code><a title="mdreg.main.MDReg.export_fit" href="#mdreg.main.MDReg.export_fit">export_fit</a></code></li>
<li><code><a title="mdreg.main.MDReg.export_registered" href="#mdreg.main.MDReg.export_registered">export_registered</a></code></li>
<li><code><a title="mdreg.main.MDReg.fit" href="#mdreg.main.MDReg.fit">fit</a></code></li>
<li><code><a title="mdreg.main.MDReg.fit_deformation" href="#mdreg.main.MDReg.fit_deformation">fit_deformation</a></code></li>
<li><code><a title="mdreg.main.MDReg.fit_signal" href="#mdreg.main.MDReg.fit_signal">fit_signal</a></code></li>
<li><code><a title="mdreg.main.MDReg.read_elastix" href="#mdreg.main.MDReg.read_elastix">read_elastix</a></code></li>
<li><code><a title="mdreg.main.MDReg.set_array" href="#mdreg.main.MDReg.set_array">set_array</a></code></li>
<li><code><a title="mdreg.main.MDReg.set_elastix" href="#mdreg.main.MDReg.set_elastix">set_elastix</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>